# State Management

Effective state management is crucial for building scalable React applications. This guide covers various approaches from local component state to global state management solutions.

## Local State

The simplest form of state management using React's built-in hooks.

### useState Hooks

```tsx
import { useState } from 'react'

function SearchBar() {
  const [query, setQuery] = useState('')
  
  return (
    <input 
      value={query}
      onChange={(e) => setQuery(e.target.value)}
      placeholder="Search..."
    />
  )
}
```

### useReducer Hook

For more complex state logic with multiple sub-values:

```tsx
import { useReducer } from 'react'

const initialState = { count: 0, step: 1 }

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { ...state, count: state.count + state.step }
    case 'decrement':
      return { ...state, count: state.count - state.step }
    case 'setStep': 
      return { ...state, step: action.payload }
    case 'setStep':
      return { ...state, step: action.payload }
    default:
      throw new Error()
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState)
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
    </div>
  )
}
```

## Context API

Share state across multiple components without prop drilling.

### Creating Context

```tsx
import { createContext, useContext, useState } from 'react'

const ThemeContext = createContext()

export function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light')
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light')
  }
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  )
}

export const useTheme = () => {
  const context = useContext(ThemeContext)
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider')
  }
  return context
}
```

### Using Context

```tsx
function Header() {
  const { theme, toggleTheme } = useTheme()
  
  return (
    <header className={theme}>
      <button onClick={toggleTheme}>
        Switch to {theme === 'light' ? 'dark' : 'light'} mode
      </button>
    </header>
  )
}
```

## External State Management

### Zustand

Lightweight state management solution with a simple API:

```tsx
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface TodoStore {
  todos: Todo[]
  addTodo: (text: string) => void
  toggleTodo: (id: number) => void
  removeTodo: (id: number) => void
}

const useTodoStore = create<TodoStore>()(
  persist(
    (set) => ({
      todos: [],
      addTodo: (text) => set((state) => ({
        todos: [...state.todos, { id: Date.now(), text, done: false }]
      })),
      toggleTodo: (id) => set((state) => ({
        todos: state.todos.map(todo =>
          todo.id === id ? { ...todo, done: !todo.done } : todo
        )
      })),
      removeTodo: (id) => set((state) => ({
        todos: state.todos.filter(todo => todo.id !== id)
      }))
    }),
    {
      name: 'todo-storage'
    }
  )
)
```

### Redux Toolkit

For complex applications requiring predictable state updates hence:

```tsx
import { createSlice, configureStore } from '@reduxjs/toolkit'

const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: (state) => {
      state.value += 1
    },
    decrement: (state) => {
      state.value -= 1
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload
    }
  }
})

export const { increment, decrement, incrementByAmount } = counterSlice.actions

export const store = configureStore({
  reducer: {
    counter: counterSlice.reducer
  }
})
```

### TanStack Query

For server state management and caching:

```tsx
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'

function UserProfile({ userId }) {
  const queryClient = useQueryClient()
  
  const { data: user, isLoading } = useQuery({
    queryKey: ['user', userId],
    queryFn: () => fetchUser(userId),
    staleTime: 5 * 60 * 1000, // 5 minutes
  })
  
  const updateUser = useMutation({
    mutationFn: updateUserAPI,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['user', userId] })
    }
  })
  
  if (isLoading) return <Spinner />
  
  return (
    <div>
      <h1>{user.name}</h1>
      <button onClick={() => updateUser.mutate({ id: userId, name: 'New Name' })}>
        Update Name
      </button>
    </div>
  )
}
```

## State Management Patterns

### Lifting State Up:

```tsx
function Parent() {
  const [sharedValue, setSharedValue] = useState('')
  
  return (
    <>
      <ChildA value={sharedValue} onChange={setSharedValue} />
      <ChildB value={sharedValue} />
    </>
  )
}
```

### Compound Components

```tsx
const Tabs = ({ children, defaultTab }) => {
  const [activeTab, setActiveTab] = useState(defaultTab)
  
  return (
    <TabContext.Provider value={{ activeTab, setActiveTab }}>
      {children}
    </TabContext.Provider>
  )
}

Tabs.List = ({ children }) => <div className="tab-list">{children}</div>
Tabs.Tab = ({ value, children }) => {
  const { activeTab, setActiveTab } = useContext(TabContext)
  return (
    <button 
      className={activeTab === value ? 'active' : ''}
      onClick={() => setActiveTab(value)}
    >
      {children}
    </button>
  )
}
```

## Performance Optimization

### Memoization

```tsx
import { useMemo, useCallback, memo } from 'react'

const ExpensiveComponent = memo(({ data, onUpdate }) => {
  const processedData = useMemo(() => 
    expensiveComputation(data), 
    [data]
  )
  
  const handleClick = useCallback(() => {
    onUpdate(processedData)
  }, [processedData, onUpdate])
  
  return <div onClick={handleClick}>{processedData}</div>
})
```

### State Colocation

Keep state as close to where it's used as possible:

```tsx
// Good - state is colocated with its usage
function SearchResults() {
  const [filter, setFilter] = useState('')
  return <div>...</div>
}

// Avoid - unnecessary lifting
function App() {
  const [filter, setFilter] = useState('') // Only used in SearchResults
  return <SearchResults filter={filter} setFilter={setFilter} />
}
```

## Best Practices

1. **Start Simple**: Use local state until you need to share it

2. **Normalize Data**: Store data in a flat structure with IDs as keys

3. **Single Source of Truth**: Each piece of state should have one authoritative source

4. **Immutable Updates**: Never mutate state directly

5. **Separate Concerns**: Keep UI state separate from server state

## Debugging State

### React DevTools

Install the React DevTools browser extension to inspect component state and props.

### Redux DevTools

```tsx
const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production'
})
```

### Custom Logging

```tsx
function useStateWithLog(initialValue, name) {
  const [value, setValue] = useState(initialValue)
  
  const setValueWithLog = useCallback((newValue) => {
    console.log(`${name} changing from`, value, 'to', newValue)
    setValue(newValue)
  }, [value, name])
  
  return [value, setValueWithLog]
}
```
