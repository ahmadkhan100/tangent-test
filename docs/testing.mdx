# Testing

Testing is crucial for maintaining code quality and preventing regressions in your React application.

## Testing Strategy hello i amm

Our application uses a comprehensive testing approach:

* **Unit Tests**: Test individual components and functions in isolation

* **Integration Tests**: Test how components work together

* **End-to-End Tests**: Test complete user workflows

## Testing Libraries

### Vitest

Fast unit test framework with excellent TypeScript support and HMR capabilities.

```bash
npm install -D vitest @testing-library/react @testing-library/jest-dom
```

### React Testing Library

Focuses on testing components the way users interact with them.

```tsx
import { render, screen, fireEvent } from '@testing-library/react'
import { Counter } from './Counter'

test('increments count when button is clicked', () => {
  render(<Counter />)
  const button = screen.getByText(/increment/i)
  fireEvent.click(button)
  expect(screen.getByText(/count: 1/i)).toBeInTheDocument()
})
```

## Component Testing

### Testing User Interactions

```tsx
import { render, screen, fireEvent } from '@testing-library/react'
import { TodoList } from './TodoList'

describe('TodoList', () => {
  test('adds new todo item', () => {
    render(<TodoList />)
    const input = screen.getByPlaceholderText(/add todo/i)
    const button = screen.getByText(/add/i)
    
    fireEvent.change(input, { target: { value: 'New Task' } })
    fireEvent.click(button)
    
    expect(screen.getByText('New Task')).toBeInTheDocument()
  })
})
```

### Testing Async Operations

```tsx
import { render, screen, waitFor } from '@testing-library/react'
import { UserCard } from './UserCard'

test('loads and displays user data', async () => {
  render(<UserCard userId="123" />)
  
  await waitFor(() => {
    expect(screen.getByText(/john doe/i)).toBeInTheDocument()
  })
})
```

## Mocking

### Mocking API Calls

```tsx
import { vi } from 'vitest'

vi.mock('./api', () => ({
  fetchUser: vi.fn(() => Promise.resolve({
    id: '123',
    name: 'John Doe',
    email: 'john@example.com'
  }))
}))
```

### Mocking Components

```tsx
vi.mock('./ExpensiveComponent', () => ({
  default: () => <div>Mocked Component</div>
}))
```

## Coverage Reports

Generate coverage reports to identify untested code:

```json
{
  "scripts": {
    "test": "vitest",
    "test:coverage": "vitest --coverage"
  }
}
```

## Best Practices

1. **Test Behavior, Not Implementation**: Focus on what the component does, not how

2. **Use Descriptive Test Names**: Make it clear what's being tested

3. **Keep Tests Independent**: Each test should run in isolation

4. **Test Edge Cases**: Don't just test the happy path

5. **Use Data-testid Sparingly**: Prefer accessible queries like getByRole or getByText

## Continuous Integration

Set up automated testing in your CI pipeline:

```yaml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
      - run: npm ci
      - run: npm test
      - run: npm run test:coverage
```
